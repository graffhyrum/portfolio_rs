<section>
  <h2>
    Gists
  </h2>
  <p>
    This is a collection of gists that I have created.
  </p>
  <ul role="list">
    <li>
      <a target="_blank" href="https://gist.github.com/graffhyrum/7f267cea2021ad4246be23ec5f6d4a4e">Typescript -
        Recursive Partial Type</a>
      <br>
      <p>
        A recursive version of the Partial type. The RecursivePartial utility type can be used in scenarios where you
        want to make all properties of an object (including nested properties) optional.
      </p>
      <pre>
      <code class="language-typescript">
/**
 * A custom utility type to allow an object to be only one Type from the provided
 * Type.
 * @example
 * type OneOf = OneOfType&lt;{userId:string, userEmail:string}&gt;;
 * //allows {userId:string} || {userEmail:string}, but not both
 */
export type OneOfType&lt;T&gt; = ValueOf&lt;OneOfByKey&lt;T&gt;&gt;;
type OneOfByKey&lt;T&gt; = {[key in keyof T]: OneOnly&lt;T, key&gt;};
type OneOnly&lt;Obj, Key extends keyof Obj&gt; = {
  [key in Exclude&lt;keyof Obj, Key&gt;]+?: undefined;
} &amp; Pick&lt;Obj, Key&gt;;
type ValueOf&lt;Obj extends object&gt; = Obj[keyof Obj];
      </code>
      </pre>
    </li>
    <li>
      <a target="_blank" href="https://gist.github.com/graffhyrum/d705dc05cf3890303dd9aa1c9598b08d">Typescript - "One
        of" Type</a>
      <br>
      <p>
        A utility type OneOfType that ensures an object can only have one property from the provided type. This is
        achieved using TypeScript's conditional and mapped types.
      </p>
      <pre>
      <code class="language-typescript">
/**
 * A custom utility type to allow an object to be only one Type from the provided
 * Type.
 * @example
 * type OneOf = OneOfType&lt;{userId:string, userEmail:string}&gt;;
 * //allows {userId:string} || {userEmail:string}, but not both
 */
export type OneOfType&lt;T&gt; = ValueOf&lt;OneOfByKey&lt;T&gt;&gt;;
type OneOfByKey&lt;T&gt; = {[key in keyof T]: OneOnly&lt;T, key&gt;};
type OneOnly&lt;Obj, Key extends keyof Obj&gt; = {
  [key in Exclude&lt;keyof Obj, Key&gt;]+?: undefined;
} &amp; Pick&lt;Obj, Key&gt;;
type ValueOf&lt;Obj extends object&gt; = Obj[keyof Obj];
      </code>
      </pre>
    </li>
    <li>
      <a target="_blank" href="https://gist.github.com/graffhyrum/1253b24fbe80d5f508544736d83d9532">Typescript -
        Type-safe Entries</a>
      <br>
      <p>
        A utility for working with objects in a type-safe manner. It defines a type Entries and a function getEntries.
      </p>
      <pre>
      <code class="language-typescript">
export type Entries&ltT&gt = {
  [K in keyof T]-?: [K, T[K]];
}[keyof T][];

export const getEntries = &ltT extends object&gt(obj: T): Entries&ltT&gt =&gt {
  return Object.entries(obj) as Entries&ltT&gt;
};

const exampleObj = {
  name: 'John',
  age: 30,
  location: 'New York',
};

const entries = getEntries(exampleObj);
// type of entries is:
// type Entries = ["name", string] | ["age", number] | ["location", string]
const entries2 = Object.entries(exampleObj);
// type of entries2 is:
// type Entries2 = [keyof typeof exampleObj, string | number][]
      </code>
      </pre>
    </li>
    <li>
      <a target="_blank" href="https://gist.github.com/graffhyrum/bdf39a9e7fe18876fcc1dabf11c92457">Typescript -
        Branded Types</a>
      <br>
      <p>
A "Branded" type is a type that is a subtype of the original type, but has a unique literal value in a common field (the brand). This allows us to define types that are more specific than the original type, but are still compatible with it.
      </p>
      <pre>
      <code class="language-typescript">
export type EmailAddress = string & {__brand: 'emailAddress'};

/**
 * EmailAddress assertion function
 */
export function assertIsEmailAddress(
  emailAddress: unknown
): asserts emailAddress is EmailAddress {
  if (!isEmailAddress(emailAddress)) {
    throw new Error(`Expected ${emailAddress} to be a valid email address`);
  }
}

/**
 * Email address type check function
 */
export function isEmailAddress(
  emailAddress: unknown
): emailAddress is EmailAddress {
  const emailRegex = /^[\w-.]+@([\w-]+\.)+[\w-]{2,4}$/;
  if (typeof emailAddress === 'string') {
    return emailAddress.match(emailRegex) !== null;
  } else {
    return false;
  }
}
      </code>
      </pre>
    </li>
  </ul>
</section>
